AWSTemplateFormatVersion: '2010-09-09'
Description: AWS Control Tower Lifecycle Events for CloudKnox (MPCT-yseaalnf)



# ----------------------------------------------------------------------------------------------------------
#  CloudFormation Template 1 of 1 - 
#   
#   This templates allows newly added Control Tower accounts to be managed automatically by CloudKnox
#                                  
#   This template provisions infrastructure in the AWS Control Tower Management account that allows creation of Datadog 
#   stack instances in Control Tower managed accounts whenever a new Control Tower managed account is added
#  
#  1- Creates a CloudKnox Stackset in the AWS Control Tower Management Account 
#  2- Provisions a CloudWatchEvents Rule that is triggered based on a Control Tower Lifecycle Event
#  3- Provisions a Lifecyle Lambda as a target for the CloudWatch Events Rule.
#    - The Lifecycle Lambda deploys a CloudKnox stack in the newly added Control Tower managed account--thus placing 
#      that account under CloudKnox management
#     - Lifecycle Lambda performs a POST on the CloudKnox Account Membership API  - that
#       registers the new AWS managed account in CloudKnox 
#   
# 
#  The infrastructure provisioned by this template in Steps 1-3 allows for a Control Tower lifecycle
#  event trigger (CreateManagedAccount) to 
#       - Trigger the Lifecyle Lambda that creates CloudKnox stack instance in the managed account based on the
#        CloudKnox stackset in the Management account
#     
##
## @kmmahaj
## 
#
# ------------------------------------------------------------...............................................

Parameters:
  CloudKnoxTemplateURL:
    Description: >-
      Base URL for CloudKnox CloudFormation template - CloudKnox Integration Role template
    Type: String
    Default: 'https://cloudknox-controltower-template.s3.amazonaws.com/member-account.yaml'
  orgId:
    Description: >-
      CloudKnox Organization ID
    Type: String
    Default: "LCyGYFUoRHWTq1FzuvVeLb2SKrDlZR7Z"
  dataCollectorGroupId:
    Description: >-
      REQUIRED. API key for the Datadog account (find at
      https://app.datadoghq.com/account/settings#api)
    Type: String
    Default: "C7X2gqIwnU4XD3GRfIzQezF0z4T30HDp"
  CloudKnoxSentryIAMRoleName:
    Description: IAM role provisioned for CloudKnox Sentry
    Type: String
    Default: IAM_R_KNOX_SECURITY
  CloudKnoxSentryAccountId:
    Description: >-
      CloudKnox Sentry AWS Account ID
    Type: String
    Default: "341476298946"
  

Resources:

# ---------------------------------------------------------------------------------------------------
#  
#  1- Store Parameters for the CloudKnox StackSet in AWS Secrets Manager
#  2- Create a CloudKnox StackSet in the Control Tower Management Account
#      - The CloudKnox StackSet is based on the CloudKnox member.yaml template that is provided by CloudKnox. 
#      - The CloudKnox member.yaml template provisions the CloudKnox Cross Account Role
# --------------------------------------------------------------------------------------------------

  CloudKnoxSecretString:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: CloudKnox Parameters 
      Name: CloudKnoxSecretString
      SecretString:
        Fn::Join:
        - ''
        - - '{"orgId":"'
          - Ref: orgId
          - '","dataCollectorGroupId": "'
          - Ref: dataCollectorGroupId
          - '"}'
  
  CreateCloudKnoxStackSet:
    Type: 'Custom::CloudKnoxStackSet'
    DependsOn:
      - CloudKnoxStackSetLambdaExecutePermission
    Properties:
      ServiceToken: !GetAtt 'CloudKnoxStackSetLambda.Arn'
      cloudknoxUrl: !Ref CloudKnoxTemplateURL
      AccountId: !Ref CloudKnoxSentryAccountId
      ControlTowerMgmtAccountId: !Ref 'AWS::AccountId'
      CloudKnoxSentryIAMRoleName: !Ref CloudKnoxSentryIAMRoleName

  CloudKnoxStackSetLambdaExecutePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt 'CloudKnoxStackSetLambda.Arn'
      Principal: 'cloudformation.amazonaws.com'
      SourceAccount: !Ref 'AWS::AccountId'
   
      
  CloudKnoxStackSetLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      Runtime: python3.7
      MemorySize: 256
      Role: !GetAtt 'CloudKnoxStackSetLambdaExecutionRole.Arn'
      Timeout: 60
      Code:
        ZipFile: |
          import json
          import boto3
          import botocore
          import os
          import cfnresponse
          import logging
          from botocore.vendored import requests

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def handler(event, context):
          
              AccountId = event['ResourceProperties']['AccountId']
              ControlTowerMgmtAccountId = event['ResourceProperties']['ControlTowerMgmtAccountId']
              cloudknoxUrl = event['ResourceProperties']['cloudknoxUrl']
              cloudknoxsentryiamrolename = event['ResourceProperties']['CloudKnoxSentryIAMRoleName']

              cList = ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND']
              ExecRole = 'AWSControlTowerExecution'
              AdminRoleARN = 'arn:aws:iam::'+ ControlTowerMgmtAccountId + ':role/service-role/AWSControlTowerStackSetRole'
              logger.info('EVENT Received: {}'.format(event))
              response_data = {}
              eventType = event['RequestType']

              if eventType != 'Delete':
                  logger.info('Event = ' + event['RequestType'])
                  cloudknox_paramList = []
                  keyDict1 = {}
                  keyDict1['ParameterKey'] = 'CloudKnoxSentryIAMRoleName'
                  keyDict1['ParameterValue'] = cloudknoxsentryiamrolename
                  cloudknox_paramList.append(keyDict1)
                  keyDict2 = {}
                  keyDict2['ParameterKey'] = 'CloudKnoxSentryAccountId'
                  keyDict2['ParameterValue'] = AccountId
                  cloudknox_paramList.append(keyDict2)
                  
                  logger.info('CloudKnox ParamList:{}'.format(cloudknox_paramList))
                  cloudformation = boto3.client('cloudformation')
                  cloudknox_result = cloudformation.create_stack_set(StackSetName='CloudKnoxMemberRolev1', \
                                      Description = 'Cross Account Role for CloudKnox', \
                                      TemplateURL = cloudknoxUrl, \
                                      Parameters = cloudknox_paramList, \
                                      AdministrationRoleARN = AdminRoleARN, \
                                      ExecutionRoleName = ExecRole, \
                                      Capabilities = cList )
  
                  logger.info('CloudKnox Stackset: {}'.format(cloudknox_result))
                  cfnsend(event, context, 'SUCCESS', response_data)
                  return "Success"

              else:
                  logger.info(f'Request Type is Delete; unsupported')
                  cfnsend(event, context, 'SUCCESS', response_data)
                  return event

              cfnsend(event, context, 'SUCCESS', response_data)
              return "Success"

     
          def cfnsend(event, context, responseStatus, responseData, reason=None):
              if 'ResponseURL' in event:
                  responseUrl = event['ResponseURL']
                  # Build out the response json
                  responseBody = {}
                  responseBody['Status'] = responseStatus
                  responseBody['Reason'] = reason or 'CWL Log Stream =' + context.log_stream_name
                  responseBody['PhysicalResourceId'] = context.log_stream_name
                  responseBody['StackId'] = event['StackId']
                  responseBody['RequestId'] = event['RequestId']
                  responseBody['LogicalResourceId'] = event['LogicalResourceId']
                  responseBody['Data'] = responseData
                  json_responseBody = json.dumps(responseBody)

                  logger.info(f'Response body: + {json_responseBody}')

                  headers = {
                      'content-type': '',
                      'content-length': str(len(json_responseBody))
                  }
                  # Send response back to CFN
                  try:
                      response = requests.put(responseUrl,
                                              data=json_responseBody,
                                              headers=headers)
                      logger.info(f'Status code: {response.reason}')
                  except Exception as e:
                      logger.info(f'send(..) failed executing requests.put(..):  {str(e)}')
  

  CloudKnoxStackSetLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "CloudKnoxStackSetLambdaExecutionRole-${AWS::Region}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
            Condition: {}
      Path: /
      Policies:
        - PolicyName: GetSecretValue
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: Secrets1
              Effect: Allow
              Action:
                - secretsmanager:GetSecretValue
              Resource: !Ref CloudKnoxSecretString
        - PolicyName: ListSecrets
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: Secrets2
              Effect: Allow
              Action:
                - secretsmanager:ListSecrets
              Resource: '*'
        - PolicyName: CloudFormation_ops
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: VisualEditor2
              Effect: Allow
              Action:
                - cloudformation:CreateStackSet
              Resource: !Join [':', ['arn:aws:cloudformation', !Ref 'AWS::Region', !Ref 'AWS::AccountId', 'stackset/CloudKnoxMemberRolev1:*']]
        - PolicyName: Pass_Role
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Sid: VisualEditor3
              Effect: Allow
              Action:
                - iam:PassRole
              Resource: !Join [':', ['arn:aws:iam:', !Ref "AWS::AccountId", 'role/service-role/AWSControlTowerStackSetRole']]
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSOrganizationsReadOnlyAccess
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess


# --------------------------------------------------------------------------------------------------
# 
#  1- Provisions a CloudWatchEvents Rule that is triggered based on a Control Tower Lifecycle Event
#  2- Provisions a Lifecyle Lambda as a target for the CloudWatch Events Rule.
# 
# --------------------------------------------------------------------------------------------------

  CloudKnoxCaptureControlTowerLifeCycleEvents:
    DependsOn:
    - TriggerCustomizationsOnLifeCycleEvent
    Type: AWS::Events::Rule
    Properties:
      Description: Capture Control Tower LifeCycle Events for CloudKnox and Trigger an Action
      EventPattern:
        detail:
          eventName:
          - CreateManagedAccount
          - UpdateManagedAccount
          - EnableGuardrail
          - DisableGuardrail
          - SetupLandingZone
          - UpdateLandingZone
          - RegisterOrganizationalUnit
          - DeregisterOrganizationalUnit
          eventSource:
          - controltower.amazonaws.com
        detail-type:
        - AWS Service Event via CloudTrail
        source:
        - aws.controltower
      Name: CloudKnoxCaptureControlTowerLifeCycleEvents
      State: ENABLED
      Targets:
      - Arn: !GetAtt "TriggerCustomizationsOnLifeCycleEvent.Arn"
        Id: IDCaptureControlTowerLifeCycleEvents

  LambdaRoleToCaptureEvents:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "CloudKnoxLambdaRoleToCaptureEvents-${AWS::Region}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
            Condition: {}
      Path: /
      Policies:
        - PolicyName: inline-policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'cloudformation:CreateStackInstances'
                Resource: !Join [':',['arn:aws:cloudformation', !Ref 'AWS::Region', !Ref 'AWS::AccountId', 'stackset/CloudKnoxMemberRolev1:*']]
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  TriggerCustomizationsOnLifeCycleEvent:
    DependsOn:
    - LambdaRoleToCaptureEvents
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import logging
          import urllib.request

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          stackset_list = ['CloudKnoxMemberRolev1']
          result = {"ResponseMetadata":{"HTTPStatusCode":"400"}}
          
          def get_secret_value(key='CloudKnoxSecretString'):
              secretsmanager = boto3.client('secretsmanager')
              secret_list = secretsmanager.list_secrets()['SecretList']
              output = {}
              for s in secret_list:
                  if key in s.values():
                      output = secretsmanager.get_secret_value(SecretId=key)['SecretString']
              return(output)

          def invoke_cloudknox_membership_api(accountid,CloudKnoxSentryAccountId):
              
              secretList = json.loads(get_secret_value('CloudKnoxSecretString'))
              orgId=""
              dataCollectorGroupId=""
 
              orgId_key='orgId'
              dataCollectorGroupId_key='dataCollectorGroupId'

              
              if orgId_key in secretList:
                  orgId = secretList[orgId_key]
              if dataCollectorGroupId_key in secretList:
                  dataCollectorGroupId = secretList[dataCollectorGroupId_key]

              
              account_id = accountid
              headers = {
                'accessKey': 'cloudKnox',
                'Content-Type': 'application/json'
              }

              cloudknoxDict = {}
              cloudknoxDict['orgId'] = orgId
              cloudknoxDict['dataCollectorGroupId'] = dataCollectorGroupId
              cloudknoxDict['requestType'] = 'ADD_AUTH_SYSTEM'
              cloudknoxDict['authorizationSystemId'] = CloudKnoxSentryAccountId
              cloudknoxDict['requestId'] = CloudKnoxSentryAccountId + '_DEMO'
          
              cloudknoxDict['accountRoles'] = [{'id': accountId,
                                                 'rolename': 'IAM_R_KNOX_SECURITY_XA'}]
              payload = json.dumps(cloudknoxDict)
              print('payload-accessToken: ' + payload)
    
              conn.request("POST", "ohare.cloudknox.io/job", payload, headers)
              res = conn.getresponse()
              data = res.read()
              dataResponse = json.loads(data.decode("utf-8"))

              return

          def lambda_handler(event, context):
              masterAcct = event['account']
              CloudKnoxSentryAccountId = os.environ['CloudKnoxSentryAccountId']
              eventDetails = event['detail']
              regionName = eventDetails['awsRegion']
              eventName = eventDetails['eventName']
              srvEventDetails = eventDetails['serviceEventDetails']
              if eventName == 'CreateManagedAccount' or eventName == 'UpdateManagedAccount':
                  newAccInfo = {}
                  logger.info('Event Processed Sucessfully')
                  if eventName == 'CreateManagedAccount':
                      newAccInfo = srvEventDetails['createManagedAccountStatus']
                  if eventName == 'UpdateManagedAccount':
                      newAccInfo = srvEventDetails['updateManagedAccountStatus']
                  cmdStatus = newAccInfo['state']
                  if cmdStatus == 'SUCCEEDED':
                      '''Sucessful event recieved'''
                      accId = newAccInfo['account']['accountId']
                      cloudformation = boto3.client('cloudformation')
                      for item in stackset_list:
                          try:
                              result = cloudformation.create_stack_instances(StackSetName=item,Accounts=[accId], Regions=[regionName])
                              logger.info('Processed {} Sucessfully'.format(item))
                              invoke_cloudknox_membership_api(accountid,CloudKnoxSentryAccountId)
                          except Exception as e:
                              logger.error('Unable to launch in:{}, REASON: {}'.format(item, e))
                  else:
                      '''Unsucessful event recieved'''
                      logger.info('Unsucessful Event Recieved. SKIPPING :{}'.format(event))
                      return(False)
              else:
                  logger.info('Control Tower Event Captured :{}'.format(event))
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt "LambdaRoleToCaptureEvents.Arn"
      Runtime: python3.7
      Environment:
        Variables:
          CloudKnoxSentryAccountId : !Ref CloudKnoxSentryAccountId
      Timeout: 60
      
  PermissionForEventsToInvokeLambdachk:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt "TriggerCustomizationsOnLifeCycleEvent.Arn"
      Principal: events.amazonaws.com
      SourceArn: !GetAtt "CloudKnoxCaptureControlTowerLifeCycleEvents.Arn"
